import tensorflow as tf
print("TensorFlow version:", tf.__version__)


class LSTMModel(tf.keras.Model):
    def __init__(self, depth=1, bidirectional=False, num_neurons=64, dropout_rate=0.0, weight_update_algorithm='adam'):
        super(LSTMModel, self).__init__()
        self.depth = depth
        self.bidirectional = bidirectional
        self.num_neurons = num_neurons
        self.dropout_rate = dropout_rate
        self.weight_update_algorithm = weight_update_algorithm

        # Initialize the LSTM layers based on the depth
        self.lstm_layers = []
        for _ in range(depth - 1):
            if bidirectional:
                self.lstm_layers.append(tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(units=num_neurons, return_sequences=True, dropout=dropout_rate), input_shape=(None,)))
            else:
                self.lstm_layers.append(tf.keras.layers.LSTM(units=num_neurons, return_sequences=True, dropout=dropout_rate, input_shape=(None,)))
        if bidirectional:
            self.lstm_layers.append(tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(units=num_neurons, return_sequences=False, dropout=dropout_rate), input_shape=(None,)))
        else:
            self.lstm_layers.append(tf.keras.layers.LSTM(units=num_neurons, return_sequences=False, dropout=dropout_rate, input_shape=(None,)))
    # Output Dense layer
        self.output_layer = tf.keras.layers.Dense(units=1, activation='sigmoid')

    def call(self, inputs):
        print(inputs.shape)
        x = inputs
        for lstm_layer in self.lstm_layers:
            x = lstm_layer(x)
        output = self.output_layer(x)
        return output

    def compile_model(self):
        if self.weight_update_algorithm == 'adam':
            optimizer = tf.keras.optimizers.Adam()
        else:
            raise ValueError("Unsupported weight update algorithm.")
        self.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])

    def predict_sequence(self, sequence):
        windows = [sequence[i:i+self.window_size] for i in range(0, len(sequence) - self.window_size + 1)]
        
        # Predict labels for each window
        window_predictions = [self.predict(tf.expand_dims(window, axis=0)) for window in windows]
        
        # Calculate the majority vote for the entire sequence
        majority_vote = sum(window_predictions) >= len(window_predictions) // 2
        
        return majority_vote
